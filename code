import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
import json
import os
from datetime import datetime

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

DATA_FILE = 'stories_data.json'


def load_data():
    return json.load(open(DATA_FILE, 'r')) if os.path.exists(DATA_FILE) else {'stories': [], 'ratings': {}}


def save_data(data):
    json.dump(data, open(DATA_FILE, 'w'), indent=2)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        ['üìù –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é', 'üìñ –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å—Ç–æ—Ä–∏–∏'],
        ['‚≠ê –ú–æ–∏ –∏—Å—Ç–æ—Ä–∏–∏']
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text(
        '–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∏ –æ—Ü–µ–Ω–∫–∏ –∏—Å—Ç–æ—Ä–∏–π. –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:',
        reply_markup=reply_markup
    )


async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == 'üìù –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é':
        await post_story(update, context)
    elif text == 'üìñ –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å—Ç–æ—Ä–∏–∏':
        await show_stories(update, context)
    elif text == '‚≠ê –ú–æ–∏ –∏—Å—Ç–æ—Ä–∏–∏':
        await my_stories(update, context)


async def post_story(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['awaiting_story'] = True
    await update.message.reply_text('–ù–∞–ø–∏—à–∏ —Å–≤–æ—é –∏—Å—Ç–æ—Ä–∏—é:')


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get('awaiting_story'): return

    data = load_data()
    user = update.effective_user
    story = {
        'id': len(data['stories']) + 1,
        'user_id': user.id,
        'username': user.username or user.first_name,
        'text': update.message.text,
        'date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'rating': 0,
        'votes': 0
    }

    data['stories'].append(story)
    save_data(data)
    del context.user_data['awaiting_story']
    await update.message.reply_text('–ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!')


async def show_stories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not (data := load_data())['stories']:
        return await update.message.reply_text('–ò—Å—Ç–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.')

    for story in data['stories'][-5:][::-1]:
        kb = [[InlineKeyboardButton("üëç", callback_data=f"rate_{story['id']}_1"),
               InlineKeyboardButton("üëé", callback_data=f"rate_{story['id']}_-1")]]
        await update.message.reply_text(
            f"@{story['username']}:\n{story['text']}\n–†–µ–π—Ç–∏–Ω–≥: {story['rating']}",
            reply_markup=InlineKeyboardMarkup(kb)
        )


async def handle_rating(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = load_data()
    user_id, (story_id, rating) = query.from_user.id, map(int, query.data.split('_')[1:])

    if f"{user_id}_{story_id}" in data['ratings']:
        return await query.edit_message_text(text="–í—ã —É–∂–µ –≥–æ–ª–æ—Å–æ–≤–∞–ª–∏!")

    for story in data['stories']:
        if story['id'] == story_id:
            story['rating'] += rating
            story['votes'] += 1
            data['ratings'][f"{user_id}_{story_id}"] = rating
            save_data(data)
            kb = [[InlineKeyboardButton("üëç", callback_data=f"rate_{story['id']}_1"),
                   InlineKeyboardButton("üëé", callback_data=f"rate_{story['id']}_-1")]]
            return await query.edit_message_text(
                f"@{story['username']}:\n{story['text']}\n–†–µ–π—Ç–∏–Ω–≥: {story['rating']}",
                reply_markup=InlineKeyboardMarkup(kb))


async def my_stories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = load_data()
    stories = [s for s in data['stories'] if s['user_id'] == update.effective_user.id]

    if not stories:
        return await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –∏—Å—Ç–æ—Ä–∏–π.")

    for story in stories:
        await update.message.reply_text(f"{story['date']}:\n{story['text']}\n–†–µ–π—Ç–∏–Ω–≥: {story['rating']}")


def main():
    app = Application.builder().token("Token").build()
    app.add_handlers([
        CommandHandler("start", start),
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_buttons),
        MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex('^(üìù|üìñ|‚≠ê)'), handle_buttons),
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message),
        CallbackQueryHandler(handle_rating, pattern='^rate_')
    ])
    app.run_polling()


if __name__ == '__main__':
    main()
